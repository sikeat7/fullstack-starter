# Reglas Ultra Espec√≠ficas para B2B Project API - NestJS + Prisma

## üìö CONTEXTO FUNDAMENTAL DEL PROYECTO

**IMPORTANTE:** Antes de cualquier implementaci√≥n o decisi√≥n t√©cnica, SIEMPRE consulta y basa tu trabajo en el archivo `docs/fundational.md`. Este documento contiene:

- **Visi√≥n y Misi√≥n** del proyecto B2B
- **Estrategia por fases** (MVP ‚Üí Proveedores ‚Üí Marketplace)
- **Funcionalidades espec√≠ficas** de cada m√≥dulo
- **Problemas del dominio** que estamos resolviendo
- **Modelo de negocio** y evoluci√≥n del producto
- **Principios de dise√±o** y tecnolog√≠as propuestas

El `fundational.md` es tu gu√≠a principal para entender el contexto completo del proyecto. √ösalo para:

- Validar que las funcionalidades implementadas alineen con la estrategia
- Entender el dominio del negocio antes de escribir c√≥digo
- Tomar decisiones t√©cnicas que soporten la evoluci√≥n del producto
- Mantener consistencia con la visi√≥n del equipo fundador

## üéØ CONTEXTO DEL PROYECTO

Este es un **Sistema SaaS B2B** para comerciantes (bares, restaurantes, almacenes) y proveedores (distribuidores de bebidas, alimentos, limpieza, etc.). El MVP funciona como un **ERP liviano** con el objetivo de digitalizar operaciones manuales como pedidos, pagos, remitos y facturaci√≥n. Posteriormente, se activar√° un **marketplace inteligente** con comparador de precios y √≥rdenes de compra autom√°ticas.

**Stack Tecnol√≥gico:** NestJS, TypeScript, Prisma ORM, PostgreSQL, pnpm, zod, betterAuth
**Usuarios Objetivo:** Due√±os de comercios, Proveedores mayoristas, Administradores de compras y finanzas
**Meta:** Ordenar operaciones internas, facilitar la gesti√≥n de pedidos, pagos y proveedores, y sentar bases para un marketplace B2B escalable e inteligente.

## üèóÔ∏è ARQUITECTURA Y PATRONES

### Estructura de M√≥dulos

- **Siempre** sigue la estructura modular de NestJS: `controller.ts`, `service.ts`, `module.ts`, `dto/`, `entities/`
- **Nunca** mezcles l√≥gica de negocio en controllers - solo en services
- **Siempre** usa inyecci√≥n de dependencias con `@Injectable()`
- **Siempre** implementa interfaces para servicios complejos o extensibles
- **Siempre** inyecta PrismaService mediante constructor (no uso global)
- **Siempre** mant√©n controllers finos: validan entrada y delegan a services

### Base de Datos y Prisma

- **Siempre** usa snake_case para nombres de columnas en Prisma schema
- **Siempre** incluye timestamps: `createdAt`, `updatedAt`, `deletedAt` (soft delete)
- **Siempre** usa `@map()` para mapear camelCase a snake_case
- **Siempre** valida existencia de entidades antes de crear relaciones
- **Nunca** uses `any` type - usa tipos espec√≠ficos de Prisma
- **Siempre** implementa soft delete con `deletedAt` nullable
- **Siempre** evita queries con `select *`, usa `select/include` espec√≠ficos
- **Siempre** usa transacciones Prisma para operaciones m√∫ltiples relacionadas

### Validaci√≥n y DTOs

- **Siempre** usa `class-validator` decorators en DTOs
- **Siempre** incluye `@ApiProperty()` para Swagger documentation
- **Siempre** valida longitud m√≠nima y m√°xima en strings
- **Siempre** usa regex patterns para validaciones complejas (ej: passwords, CUIT)
- **Siempre** incluye ejemplos realistas en `@ApiProperty()`
- **Siempre** valida CUIT, emails, montos positivos, fechas coherentes
- **Siempre** valida campos sensibles con regex espec√≠ficos

### Manejo de Errores

- **Siempre** usa excepciones espec√≠ficas de NestJS: `NotFoundException`, `ConflictException`, `BadRequestException`
- **Siempre** implementa `PrismaExceptionFilter` para errores de base de datos
- **Siempre** valida datos antes de operaciones de base de datos
- **Siempre** maneja casos edge (ej: email duplicado, CUIT duplicado)
- **Nunca** expongas informaci√≥n sensible en errores
- **Siempre** valida entrada antes de tocar DB

## üîê SEGURIDAD Y AUTENTICACI√ìN

### Passwords y Hashing

- **Siempre** usa bcryptjs para hashing de passwords
- **Siempre** configura rounds de hashing desde environment variables
- **Siempre** valida fortaleza de password con regex
- **Nunca** almacenes passwords en texto plano
- **Siempre** valida campos sensibles (email, password, CUIT) con regex
- **Nunca** loguees informaci√≥n confidencial

### Validaciones de Entrada

- **Siempre** valida emails con `@IsEmail()`
- **Siempre** valida CUIT con formato espec√≠fico
- **Siempre** valida montos positivos en transacciones
- **Siempre** valida fechas l√≥gicas (ej: dueDate > date)

## üìä L√ìGICA DE NEGOCIO

### Transacciones Financieras

- **Siempre** valida que `paidAmount <= totalAmount`
- **Siempre** actualiza estado de pagos y pedidos autom√°ticamente seg√∫n datos
- **Siempre** valida existencia de proveedor y usuario
- **Siempre** valida m√©todo de pago antes de crear transacci√≥n
- **Siempre** usa transacciones Prisma para operaciones m√∫ltiples relacionadas

### Proveedores

- **Siempre** valida CUIT √∫nico antes de crear
- **Siempre** valida existencia de categor√≠a obligatoria
- **Siempre** valida existencia de direcci√≥n si se proporciona
- **Siempre** valida m√©todos de pago asociados

### Paginaci√≥n y B√∫squeda

- **Siempre** implementa paginaci√≥n con `page` y `limit`
- **Siempre** incluye metadata: `total`, `totalPages`, `page`, `limit`
- **Siempre** implementa b√∫squeda case-insensitive
- **Siempre** usa `Promise.all()` para queries paralelas
- **Siempre** usa estructura de respuesta: `{ data: [], meta: { total, page, limit, totalPages } }`
- **Siempre** todos los endpoints de lista deben implementar paginaci√≥n

## üß™ TESTING Y CALIDAD

### Estructura de Tests

- **Siempre** crea tests unitarios para services
- **Siempre** crea tests e2e para endpoints
- **Siempre** mockea PrismaService en tests
- **Siempre** testea casos edge y errores
- **Siempre** cada service debe tener tests unitarios con Jest
- **Siempre** endpoints principales deben tener tests E2E
- **Siempre** testea edge cases, validaciones y errores comunes

### Cobertura de C√≥digo

- **Siempre** mant√©n cobertura > 80%
- **Siempre** testea validaciones de entrada
- **Siempre** testea manejo de errores
- **Siempre** testea l√≥gica de negocio compleja

## üìù DOCUMENTACI√ìN Y C√ìDIGO

### Swagger/OpenAPI

- **Siempre** documenta todos los endpoints con `@ApiTags()`
- **Siempre** documenta DTOs con `@ApiProperty()`
- **Siempre** incluye ejemplos realistas
- **Siempre** documenta c√≥digos de respuesta

### Comentarios y C√≥digo

- **Siempre** comenta l√≥gica de negocio compleja
- **Siempre** usa nombres descriptivos para variables
- **Siempre** agrupa imports: externos, internos, relativos
- **Siempre** usa TypeScript strict mode
- **Siempre** documenta funciones p√∫blicas con JSDoc
- **Siempre** no dejes c√≥digo comentado innecesario

## üöÄ DEPLOYMENT Y CONFIGURACI√ìN

### Environment Variables

- **Siempre** usa `ConfigService` para configuraci√≥n
- **Siempre** valida variables de entorno requeridas
- **Siempre** usa valores por defecto seguros
- **Nunca** hardcodees valores sensibles
- **Siempre** valida todas las variables de entorno con schemas
- **Siempre** nunca hardcodear valores sensibles

### Docker y CI/CD

- **Siempre** usa multi-stage builds en Dockerfile
- **Siempre** optimiza tama√±o de imagen
- **Siempre** usa usuario no-root en contenedores
- **Siempre** incluye health checks
- **Siempre** incluye healthchecks en producci√≥n

## üîÑ CONVENCIONES ESPEC√çFICAS

### Nomenclatura

- **Controllers**: `ProductController`, `SupplierController`
- **Services**: `ProductService`, `SupplierService`
- **DTOs**: `CreateProductDto`, `UpdateProductDto`
- **M√≥dulos**: `ProductModule`, `SupplierModule`
- **Tests**: `product.service.spec.ts`, `product.controller.e2e-spec.ts`

### Estructura de Respuestas

```typescript
// Para listas con paginaci√≥n
{
  data: Entity[],
  meta: {
    total: number,
    page: number,
    limit: number,
    totalPages: number
  }
}

// Para errores
{
  statusCode: number,
  message: string
}
```

### Patrones de Validaci√≥n

```typescript
// Validaci√≥n de existencia
const entity = await this.prisma.entity.findUnique({
  where: { id: entityId },
});
if (!entity) {
  throw new NotFoundException(`Entity with ID ${entityId} not found`);
}

// Validaci√≥n de unicidad
const existing = await this.prisma.entity.findUnique({
  where: { uniqueField: value },
});
if (existing) {
  throw new ConflictException('Entity already exists');
}
```

## ‚ö†Ô∏è REGLAS CR√çTICAS

1. **NUNCA** uses `any` type - siempre define tipos espec√≠ficos
2. **NUNCA** mezcles l√≥gica de negocio en controllers
3. **NUNCA** olvides validar entrada de usuario
4. **NUNCA** expongas informaci√≥n sensible en logs
5. **SIEMPRE** maneja errores de base de datos apropiadamente
6. **SIEMPRE** valida relaciones antes de crear entidades
7. **SIEMPRE** implementa soft delete para entidades principales
8. **SIEMPRE** usa transacciones para operaciones complejas

## üé® ESTILO DE C√ìDIGO

- **Siempre** usa camelCase para variables, funciones y atributos
- **Siempre** usa PascalCase para clases, interfaces y DTOs
- **Siempre** usa UPPER_SNAKE_CASE para constantes
- **Siempre** mant√©n l√≠neas < 100 caracteres
- **Siempre** usa 2 espacios por indentaci√≥n
- **Siempre** termina archivos con newline
- **Siempre** agrupa imports: externos, internos, relativos

## üîç REVISI√ìN DE C√ìDIGO

Antes de commitear, verifica:

- [ ] Todos los tests pasan
- [ ] Lint sin errores
- [ ] Swagger documentado
- [ ] DTOs con validaciones
- [ ] Errores bien manejados
- [ ] Tipos correctos (no hay any)
- [ ] Nombres descriptivos
- [ ] Controllers limpios
- [ ] L√≥gica de negocio en services

Esta configuraci√≥n asegura un c√≥digo profesional, mantenible y escalable para el **Sistema SaaS B2B ERP** con visi√≥n de marketplace inteligente.
